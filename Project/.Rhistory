ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(name = "Sales",
values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.9,.9))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
detect_outliers(ts_df, perc = .05)
detect_outliers <- function (ts, perc=0.01, gamma=0.01, return_df=FALSE, plot_ts=TRUE) {
# train a one-class SVM model
model <- ksvm(ts$sales, nu=perc, type='one-svc', kernel='rbfdot',
kpar=list((sigma=gamma))) #using radial bias f'n kernel
# time series output
ts_outliers <- data.frame(ts)
ts_outliers$index <- 0 #initializing
for (i in 0:length(as.vector(ts$sales))) {
ts_outliers$index[i] = i
}
ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(name = "",
values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.95,.9))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
detect_outliers(ts_df, perc = .05)
detect_outliers <- function (ts, perc=0.01, gamma=0.01, return_df=FALSE, plot_ts=TRUE) {
# train a one-class SVM model
model <- ksvm(ts$sales, nu=perc, type='one-svc', kernel='rbfdot',
kpar=list((sigma=gamma))) #using radial bias f'n kernel
# time series output
ts_outliers <- data.frame(ts)
ts_outliers$index <- 0 #initializing
for (i in 0:length(as.vector(ts$sales))) {
ts_outliers$index[i] = i
}
ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(name = "",
values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.95,.85))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
detect_outliers(ts_df, perc = .05)
detect_outliers <- function (ts, perc=0.01, gamma=0.01, return_df=FALSE, plot_ts=TRUE) {
# train a one-class SVM model
model <- ksvm(ts$sales, nu=perc, type='one-svc', kernel='rbfdot',
kpar=list((sigma=gamma))) #using radial bias f'n kernel
# time series output
ts_outliers <- data.frame(ts)
ts_outliers$index <- 0 #initializing
for (i in 0:length(as.vector(ts$sales))) {
ts_outliers$index[i] = i
}
ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.95,.85))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
#ts_outliers %>% count(outlier)  #use to groupby count
detect_outliers(ts_df, perc = .05)
detect_outliers <- function (ts, perc=0.01, gamma=0.01, return_df=FALSE, plot_ts=TRUE) {
# train a one-class SVM model
model <- ksvm(ts$sales, nu=perc, type='one-svc', kernel='rbfdot',
kpar=list((sigma=gamma))) #using radial bias f'n kernel
# time series output
ts_outliers <- data.frame(ts)
ts_outliers$index <- 0 #initializing
for (i in 0:length(as.vector(ts$sales))) {
ts_outliers$index[i] = i
}
ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(name="",
values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.95,.9))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
#ts_outliers %>% count(outlier)  #use to groupby count
detect_outliers(ts_df, perc = .05)
remove_outliers <- function (ts, outliers_idx, return_df = TRUE, plot_ts = TRUE) {
ts_clean <- ts
ts_clean$sales[outliers_idx] <- NA
ts_clean$sales <- na.approx(ts_clean$sales, method='linear') #interpolation
# plot the two series
ts_clean$og_sales <- ts$sales
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_clean) +
geom_line(aes(x=date, y=og_sales, color="red"), size=1) +
geom_line(aes(x=date, y=sales, color="turquoise4"), size=1) +
labs(x="Date", y="Sales",
title=glue("Outliers Removed: Found {n_outliers[2,2]}")) +
scale_color_manual(name = "Sales",
values = c("red", "turquoise4"),
labels = c("Original", "Interpolated"))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_clean)
}
}
# Detect outliers
ts_outliers <- detect_outliers(ts_df, perc = .05)
# outliers' index position
outliers_index_pos <- ts_outliers[ts_outliers$outlier == 1, 3] #'3' is the index column we created
# exclude outliers
ts_clean <- remove_outliers(ts_df, outliers_idx = outliers_index_pos)
ts_outliers <- detect_outliers(ts_df, perc = .05)
# outliers' index position
outliers_index_pos <- ts_outliers[ts_outliers$outlier == 1, 3] #'3' is the index column we created
# exclude outliers
ts_clean <- remove_outliers(ts_df, outliers_idx = outliers_index_pos)
detect_outliers <- function (ts, perc=0.01, gamma=0.01, return_df=TRUE, plot_ts=TRUE) {
# train a one-class SVM model
model <- ksvm(ts$sales, nu=perc, type='one-svc', kernel='rbfdot',
kpar=list((sigma=gamma))) #using radial bias f'n kernel
# time series output
ts_outliers <- data.frame(ts)
ts_outliers$index <- 0 #initializing
for (i in 0:length(as.vector(ts$sales))) {
ts_outliers$index[i] = i
}
ts_outliers$outlier <- predict(model)
for (i in 1:length(as.vector(ts$sales))) {
if (ts_outliers$outlier[i] == TRUE) {
ts_outliers$outlier[i] = 0
}
else {
ts_outliers$outlier[i] = 1
}
}
# plot ts w/ exposed outliers
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_outliers) +
geom_line(aes(x = index, y = sales,
color = "turquoise4"), size=1) +
geom_point(aes(x = index, y = sales),
data = . %>% filter(outlier %in% 1), color = 'red', size=3, alpha=0.5) +
labs(x="", y="", title=glue("Outliers Detection: Found {n_outliers[2,2]}")) +
scale_color_manual(name="",
values = c("turquoise4", "red"),
labels = c("Actual Values", "Outliers")) +
theme(legend.justification = c(1,0), legend.position=c(.95,.9))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_outliers)
}
}
detect_outliers(ts_df, perc = .05)
# Interpolate outliers to remove them
remove_outliers <- function (ts, outliers_idx, return_df = TRUE, plot_ts = TRUE) {
ts_clean <- ts
ts_clean$sales[outliers_idx] <- NA
ts_clean$sales <- na.approx(ts_clean$sales, method='linear') #interpolation
# plot the two series
ts_clean$og_sales <- ts$sales
n_outliers <- ts_outliers %>% count(outlier)
p <- ggplot(ts_clean) +
geom_line(aes(x=date, y=og_sales, color="red"), size=1) +
geom_line(aes(x=date, y=sales, color="turquoise4"), size=1) +
labs(x="Date", y="Sales",
title=glue("Outliers Removed: Found {n_outliers[2,2]}")) +
scale_color_manual(name = "Sales",
values = c("red", "turquoise4"),
labels = c("Original", "Interpolated"))
# conditional function output
if (plot_ts) {
print(p)
}
if (return_df) {
return(ts_clean)
}
}
ts_outliers <- detect_outliers(ts_df, perc = .05)
# outliers' index position
outliers_index_pos <- ts_outliers[ts_outliers$outlier == 1, 3] #'3' is the index column we created
# exclude outliers
ts_clean <- remove_outliers(ts_df, outliers_idx = outliers_index_pos)
plot_stationarity_test <- function (ts, sample=0.20, maxlag=30) {
# test stationarity (Augmented Dickey-Fuller test)
test <- adf.test(ts$sales, k=maxlag)
adf <- test$statistic
pval <- test$p.value
lag_order <- test$parameter
conclusion <- if (pval < 0.05) "Stationary" else "Non-Stationary"
pval_edt <- if(pval <= 0.01) "<= 0.01" else round(pval, 3)
# obtain critical values table from urca::ur.df adf test (same specs)
ts$sales %.>%
urca::ur.df(., lags = maxlag, type = "trend") %.>%
{ cv_table <- summary(.) } %.>%
{ cv_95 <- .@cval['tau3', '5pct'] }
cv_99 <- cv_table@cval['tau3', '1pct']
# plot ts with mean/std of a sample from the first x% and report on ADF
dtf_ts <- ts
sample_size <- as.integer(length(ts$sales)*sample)
dtf_ts$mean <- mean(head(dtf_ts$sales, sample_size))
dtf_ts$upper <- mean(head(dtf_ts$sales, sample_size)) +
sd(head(dtf_ts$sales, sample_size))
dtf_ts$lower <- mean(head(dtf_ts$sales, sample_size)) -
sd(head(dtf_ts$sales, sample_size))
p <- ggplot(dtf_ts, aes(x=date)) +
geom_ribbon(aes(ymax=upper, ymin=lower),
fill="grey70", alpha=.4) +
geom_line(aes(y=sales, color = "turquoise4")) +
geom_line(aes(y=mean, color = "red")) +
labs(x="Date", y="", title=glue("Augmented Dickey-Fuller Test: {conclusion} (p-value: {pval_edt})")) +
scale_color_manual(values = c("red", "turquoise4")) +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold")) +
theme(legend.position = "none") +
scale_x_date(breaks = as.Date(c("2013-01-01", "2013-07-01", "2014-01-01", "2014-07-01", "2015-01-01","2015-07-01")),
labels=c("Jan. 2013", "Jul", "Jan. 2014", "Jul", "Jan. 2015", "Jul")) +
annotate("text", x=as.Date("2015-07-01"), y=c(12000, 11250, 10500),
label=c(glue("95% CV: {cv_95}"),
glue("99% CV: {cv_99}"),
glue("ADF Stat: {round(adf,2)}")))
# pacf (for AR) and acf (for MA)
lower_ylim <- min(min(acf(ts$sales, plot=F)$acf),
min(pacf(ts$sales, plot=F)$acf))   #automating graph alignment
acf_plot <- ggAcf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Autocorrelation (for MA component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
pacf_plot <- ggPacf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Partial Autocorrelation (for AR component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
#arrange plots with patchwork::
p / (acf_plot + pacf_plot)
}
plot_stationarity_test(ts, sample = 0.20, maxlag=30)
plot_stationarity_test <- function (ts, sample=0.20, maxlag=30) {
# test stationarity (Augmented Dickey-Fuller test)
test <- adf.test(ts$sales, k=maxlag)
adf <- test$statistic
pval <- test$p.value
lag_order <- test$parameter
conclusion <- if (pval < 0.05) "Stationary" else "Non-Stationary"
pval_edt <- if(pval <= 0.01) "<= 0.01" else round(pval, 3)
# obtain critical values table from urca::ur.df adf test (same specs)
ts$sales %.>%
urca::ur.df(., lags = maxlag, type = "trend") %.>%
{ cv_table <- summary(.) } %.>%
{ cv_95 <- .@cval['tau3', '5pct'] }
cv_99 <- cv_table@cval['tau3', '1pct']
# plot ts with mean/std of a sample from the first x% and report on ADF
dtf_ts <- ts
sample_size <- as.integer(length(ts$sales)*sample)
dtf_ts$mean <- mean(head(dtf_ts$sales, sample_size))
dtf_ts$upper <- mean(head(dtf_ts$sales, sample_size)) +
sd(head(dtf_ts$sales, sample_size))
dtf_ts$lower <- mean(head(dtf_ts$sales, sample_size)) -
sd(head(dtf_ts$sales, sample_size))
p <- ggplot(dtf_ts, aes(x=date)) +
geom_ribbon(aes(ymax=upper, ymin=lower),
fill="grey70", alpha=.4) +
geom_line(aes(y=sales, color = "turquoise4")) +
geom_line(aes(y=mean, color = "red")) +
labs(x="Date", y="", title=glue("Augmented Dickey-Fuller Test: {conclusion} (p-value: {pval_edt})")) +
scale_color_manual(values = c("red", "turquoise4")) +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold")) +
theme(legend.position = "none") +
scale_x_date(breaks = as.Date(c("2013-01-01", "2013-07-01", "2014-01-01", "2014-07-01", "2015-01-01","2015-07-01")),
labels=c("Jan. 2013", "Jul", "Jan. 2014", "Jul", "Jan. 2015", "Jul")) +
annotate("text", x=as.Date("2015-07-01"), y=c(12000, 11250, 10500),
label=glue("ADF Stat: {round(adf,2)}"))
# pacf (for AR) and acf (for MA)
lower_ylim <- min(min(acf(ts$sales, plot=F)$acf),
min(pacf(ts$sales, plot=F)$acf))   #automating graph alignment
acf_plot <- ggAcf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Autocorrelation (for MA component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
pacf_plot <- ggPacf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Partial Autocorrelation (for AR component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
#arrange plots with patchwork::
p / (acf_plot + pacf_plot)
}
plot_stationarity_test(ts, sample = 0.20, maxlag=30)
plot_stationarity_test <- function (ts, sample=0.20, maxlag=30) {
# test stationarity (Augmented Dickey-Fuller test)
test <- adf.test(ts$sales, k=maxlag)
adf <- test$statistic
pval <- test$p.value
lag_order <- test$parameter
conclusion <- if (pval < 0.05) "Stationary" else "Non-Stationary"
pval_edt <- if(pval <= 0.01) "<= 0.01" else round(pval, 3)
# obtain critical values table from urca::ur.df adf test (same specs)
ts$sales %.>%
urca::ur.df(., lags = maxlag, type = "trend") %.>%
{ cv_table <- summary(.) } %.>%
{ cv_95 <- .@cval['tau3', '5pct'] }
cv_99 <- cv_table@cval['tau3', '1pct']
# plot ts with mean/std of a sample from the first x% and report on ADF
dtf_ts <- ts
sample_size <- as.integer(length(ts$sales)*sample)
dtf_ts$mean <- mean(head(dtf_ts$sales, sample_size))
dtf_ts$upper <- mean(head(dtf_ts$sales, sample_size)) +
sd(head(dtf_ts$sales, sample_size))
dtf_ts$lower <- mean(head(dtf_ts$sales, sample_size)) -
sd(head(dtf_ts$sales, sample_size))
p <- ggplot(dtf_ts, aes(x=date)) +
geom_ribbon(aes(ymax=upper, ymin=lower),
fill="grey70", alpha=.4) +
geom_line(aes(y=sales, color = "turquoise4")) +
geom_line(aes(y=mean, color = "red")) +
labs(x="Date", y="", title=glue("Augmented Dickey-Fuller Test: {conclusion} (p-value: {pval_edt})")) +
scale_color_manual(values = c("red", "turquoise4")) +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold")) +
theme(legend.position = "none") +
scale_x_date(breaks = as.Date(c("2013-01-01", "2013-07-01", "2014-01-01", "2014-07-01", "2015-01-01","2015-07-01")),
labels=c("Jan. 2013", "Jul", "Jan. 2014", "Jul", "Jan. 2015", "Jul")) +
annotate("text", x=as.Date("2015-07-01"), y=10500,
label=glue("ADF Stat: {round(adf,2)}"))
# pacf (for AR) and acf (for MA)
lower_ylim <- min(min(acf(ts$sales, plot=F)$acf),
min(pacf(ts$sales, plot=F)$acf))   #automating graph alignment
acf_plot <- ggAcf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Autocorrelation (for MA component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
pacf_plot <- ggPacf(ts$sales, lag.max=maxlag, ci=0.95) +
ylim(c(lower_ylim, 1)) +
geom_point(aes(x=lag, y=Freq), color="blue", shape=21, size=1.5, stroke=1.5, fill="white") +
labs(y="", title="Partial Autocorrelation (for AR component)") +
theme_minimal() +
theme(plot.title = element_text(hjust=0.5, size=12, face="bold"))
#arrange plots with patchwork::
p / (acf_plot + pacf_plot)
}
plot_stationarity_test(ts, sample = 0.20, maxlag=30)
lag_ts <- ts %>% mutate_all(lag, n=1)
lag_ts$sales <- ts$sales - lag_ts$sales
lag_ts$date <- ts$date
lag_ts <- lag_ts[rowSums(is.na(lag_ts))==0,]
plot_stationarity_test(lag_ts, sample = 0.20, maxlag=30)
ts$sales %.>%
{ units <- ts(., frequency = 7) } %.>%   #weekly seasonality
{ decomp <- stl(., s.window='periodic') }
original_plt <- ggplot(ts, aes(x=date, y=sales)) +
geom_line(color="#006699") +
theme_4panel +
labs(title="Original series") +
date_breaks_4panel
trend_plt <- decomp %.>%
{ .$time.series[,2] } %.>%
{ trend <- cbind(data.frame(.), ts$date) } %.>%
{ colnames(trend) <- c("trend", "date") } %.>%
ggplot(trend, aes(x=date, y=trend)) %.>%
geom_line(color="#006699") %.>%
theme_4panel %.>%
labs(title="Trend") %.>%
date_breaks_4panel
seasonal_plt <- decomp %.>%
{ .$time.series[,1] } %.>%
{ seasonal <- cbind(data.frame(.), ts$date) } %.>%
{ colnames(seasonal) <- c("seasonal", "date") } %.>%
ggplot(seasonal, aes(x=date, y=seasonal)) %.>%
geom_line(color="#006699") %.>%
theme_4panel %.>%
labs(title="Seasonal") %.>%
date_breaks_4panel
residual_plt <- decomp %.>%
{ .$time.series[,3] } %.>%
{ residual <- cbind(data.frame(.), ts$date) } %.>%
{ colnames(residual) <- c("residual", "date") } %.>%
ggplot(residual, aes(x=date, y=residual)) %.>%
geom_line(color="#006699") %.>%
theme_minimal() %.>%
labs(title="Residual") %.>%
theme(axis.title.y = element_blank(),
plot.title = element_text(hjust=0.5, vjust=-.5, size=10),
plot.margin = unit(c(0,0,0,0), "cm"),
panel.border = element_rect(color="black", fill=NA, size=.5)) %.>%
scale_x_date(breaks = as.Date(c("2013-01-01", "2013-05-01", "2013-09-01",
"2014-01-01", "2014-05-01", "2014-09-01",
"2015-01-01", "2015-05-01", "2015-09-01")),
date_labels = "%Y-%m")   #unfortunately can't get date_breaks = "4 months" to pull correct labels
original_plt /
trend_plt /
seasonal_plt /
residual_plt
