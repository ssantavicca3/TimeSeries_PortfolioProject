stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA" &
str_index(forecast, start=14,stop=14, int=F) != "") {
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18))
if (sum_s_params > 0) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
# display plot panel
(p1 + p2) /
(p3 + p4) +
plot_annotation(
title = 'Evaluation of Model Performance',
subtitle = paste('Model Specification:', sep=" ", cu.subtitle),
caption = glue('Training set :  n={length(train)} ({round(100*(length(train)/(length(train)+length(test))))}%)
Test set :         n={length(test)} ({round(100*(length(test)/(length(train)+length(test))))}%)'),
theme = theme(plot.title = element_text(hjust=0.5, size=15, face="bold"),
plot.subtitle = element_text(hjust=0.5, size=12)))
# Alternative color options:
# darkish green: #009900
# good blue: #3399FF
# thicker turquiose: #00CCCC
# deeper near-burghandy red: #CC3333
# brighter off-red: #FF6666
}
if (str_index(forecast = fx.1, start=1, stop=5, int=F) == "ARIMA" &
str_index(forecast = fx.1, start=14,stop=14, int=F) != "") {
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18))
if (sum_s_params > 0) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
forecast = fx.1
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA" &
str_index(forecast, start=14,stop=14, int=F) != "") {
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18))
if (sum_s_params > 0) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
cu.subtitle
plot_eval_forecast(ts, fx.2, train=train, test=test, og_df.date_col = ts_clean$date)
forecast = fx.2
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA" &
str_index(forecast, start=14,stop=14, int=F) != "") {
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18))
if (sum_s_params > 0) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
fx.2$method
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18))
str_index(forecast, 14, 14)
str_index(forecast, 16, 16)
str_index(forecast, 18, 18)
substr(forecast$method, 14, 14)
substr(forecast$method, 16, 16)
substr(forecast$method, 15, 15)
fx.2$method
substr(forecast$method, 17, 17)
substr(fx.2$method, 17, 17)
for (i in 1:24) {
print(substr(fx.2$method, i, i))
}
tst <- c(0,0)
tst
tst <- c(0,0)
for (i in 1:24) {
tst[1][i] <- substr(fx.2$method, i, i)
tst[2][i] <- i
print(tst)
}
tst <- c(0,1)
tst[1]
tst[2]
tst <- tibble(index = 0,
value = 0)
tst[2]
tst[1]
tst <- fitted = numeric(24)
tst <- numeric(24)
tst
tst <- tibble(index = 1:24,
value = 0)
tst
tst <- tibble(index = 1:24,
value = "")
tst
tst$index
tst$index[5]
for (i in 1:24) {
tst$value[i] <- substr(fx.2$method, i, i)
tst$index[i] <- i
print(tst)
}
print(tst)
print(tst[11:20,])
print(tst[20:24,])
fx.2$method
substr(fx.2$method, 17, 17)
sum_s_params <- sum(str_index(forecast, 14, 14),
str_index(forecast, 16, 16),
str_index(forecast, 18, 18), na.rm = T)
forecast$method
lenth(fx.1$method)
length(fx.1$method)
forecast = fx.2
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
cu.subtitle
forecast = fx.3
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
cu.subtitle
forecast = fx.4
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
train_test_split(ms_ts, split_perc = 0.85, full_df = T, ts_col = ts_clean$sales)
fx.4 <- fc_fn(ms_ts, modelvar = "tbats", eval_fc_output = "return fc object")
plot_eval_forecast(ms_ts, fx.4, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ms_ts, fx.4, train = train, test = test) #mape:
forecast = fx.4
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
cu.subtitle
plot_eval_forecast <- function(ts, forecast, test=test, train=train, og_df.date_col=NULL) {
# construct tmp df
eval_df <- tibble(date = og_df.date_col,
raw = ts,
model = c(forecast$fitted, rep(NA, length(test))),  #NEED TO DROP/ADD THE +1 - used it for lstm
forecasted = c(rep(NA, length(train)), forecast$mean))
# residuals
eval_df$residuals <- eval_df$raw - eval_df$model  #i.e., forecast$residuals
#eval_df$residuals <- forecast$residuals
eval_df$error <- eval_df$raw - eval_df$forecasted
eval_df$error_pct <- eval_df$error / eval_df$raw
# kpis
residuals_mean <- eval_df %.>% .$residuals %.>% mean(., na.rm = T)
residuals_sd <- eval_df %.>% .$residuals %.>% sd(., na.rm = T)
error_mean <- eval_df %.>% .$error %.>% mean(., na.rm = T)
error_sd <- eval_df %.>% .$error %.>% sd(., na.rm = T)
mae <- eval_df %.>% .$error %.>% abs(.) %.>% mean(., na.rm = T)
mape <- eval_df %.>% .$error_pct %.>% abs(.) %.>% mean(., na.rm = T)
mse <- eval_df %.>% .$error %.>% .^2 %.>% mean(., na.rm = T)
rmse <- mse %.>% sqrt(.)
# intervals
eval_df$ci_lo <- eval_df$forecasted - 1.96*residuals_sd #confidence
eval_df$ci_up <- eval_df$forecasted + 1.96*residuals_sd
eval_df$pi_lo <- eval_df$forecasted - 1.96*error_sd #prediction
eval_df$pi_up <- eval_df$forecasted + 1.96*error_sd
# plot results
theme_4panel <- function(base_size = 12,
base_family = ""){
theme_minimal(base_size = base_size,
base_family = base_family) %+replace%
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust=0.5, vjust=2, size=11),
panel.border = element_rect(color="black", fill=NA, size=.5),
legend.position = NULL,
legend.key.size = unit(1, "lines"),
legend.key.height = unit(0.7, "lines"),
legend.key.width = unit(0.7, "lines"),
legend.margin = margin(0, 0.1, 0.05, 0.1, "cm"),
legend.background = element_rect(color = 'black',
fill = 'white',
linetype = 'solid'),
legend.title = element_blank(),
legend.text = element_text(size = 10)
)
} #customizing theme_minimal()
#...training
p1 <- ggplot(eval_df[1:length(train),], aes(x=date)) +
geom_line(aes(y=raw, color="ts"), size=1) +
geom_line(aes(y=model, color="model"), size=1) +
labs(x=NULL, y='', title='Model') +
scale_color_manual(name="",
values=c("ts"="black",
"model"="#3399FF")) +
#might have to automate ylim again
ylim(c(-500, 15000))  +
theme_4panel() +
theme(legend.position = c(.075,.89)) +
scale_x_date(breaks="6 months", date_labels = "%b-%Y",
limits=c(eval_df$date[1], max=eval_df$date[length(train)]),
expand=c(0,0))
#...test
p2 <- ggplot(eval_df[length(train):length(eval_df$raw),], aes(x=date)) +
geom_ribbon(aes(ymin=pi_lo, ymax=pi_up), fill="blue", alpha=0.3) +
geom_ribbon(aes(ymin=ci_lo, ymax=ci_up), fill="lightblue", alpha=0.6) +
geom_line(aes(y=raw, color="ts"), size=1) +
geom_line(aes(y=forecasted, color="forecast"), size=1) +
labs(x='', y='', title='Forecast') +
scale_color_manual(name="",
values=c("ts"="black",
"forecast"="red")) +
ylim(c(-500, 15000)) +
theme_4panel() +
theme(legend.position = c(.91,.89)) +
scale_x_date(breaks="1 month", date_labels = "%b",
limits=c(eval_df$date[length(train)], max=max(eval_df$date)),
expand=c(0,0))
#...residuals
p3 <- ggplot(eval_df, aes(x=date)) +
geom_line(data = eval_df[1:length(train),],
aes(y=residuals, color="residuals"), size=1) +
geom_line(data = eval_df[length(train):length(eval_df$raw),],
aes(y=error, color="error"), size=1) +
labs(x='', y='', title='Residuals') +
scale_color_manual(name="",
values=c("residuals"="#3399FF",
"error"="red")) +
theme_4panel() +
theme(legend.position = c(.095,.89)) +
scale_x_date(breaks="6 months", date_labels = "%b-%Y",
limits=c(eval_df$date[1], max=max(eval_df$date)),
expand=c(0,0))
#...residuals distribution
p4 <- ggplot(eval_df) +
geom_density(data = eval_df[length(train):length(eval_df$raw),],
aes(x=error, color="error"), alpha=0.1, size=1, fill="red") +
geom_density(data = eval_df[1:length(train),],
aes(x=residuals, color="residuals"), alpha=0.2, size=1, fill="#3399FF") +
labs(x='', y='', title='Residuals Distribution') +
geom_vline(aes(xintercept=mean(error, na.rm=T), color="error"),
size=1, linetype="dashed") +
geom_vline(aes(xintercept=mean(residuals, na.rm=T), color="residuals"),
size=1, linetype="dashed") +
scale_color_manual(name="",
values=c("residuals"="#3399FF",
'error'="red")) +
scale_fill_manual(name="",
values=c('residuals'="#3399FF",
'error'="red")) +
theme_4panel() +
theme(legend.position = c(.905,.89))
# create subtitle reporting custom model specification
str_index <- function (forecast, start=NULL, stop=NULL, int=TRUE) {
#i=14,16,18 are standard seasonal parameters for forecast$method with ARIMA
if (int) {
as.integer(substr(forecast$method,
start=start,
stop=stop))
} else {
substr(forecast$method,
start=start,
stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
# display plot panel
(p1 + p2) /
(p3 + p4) +
plot_annotation(
title = 'Evaluation of Model Performance',
subtitle = paste('Model Specification:', sep=" ", cu.subtitle),
caption = glue('Training set :  n={length(train)} ({round(100*(length(train)/(length(train)+length(test))))}%)
Test set :         n={length(test)} ({round(100*(length(test)/(length(train)+length(test))))}%)'),
theme = theme(plot.title = element_text(hjust=0.5, size=15, face="bold"),
plot.subtitle = element_text(hjust=0.5, size=12)))
# Alternative color options:
# darkish green: #009900
# good blue: #3399FF
# thicker turquiose: #00CCCC
# deeper near-burghandy red: #CC3333
# brighter off-red: #FF6666
}
eval_forecast <- function (ts, forecast, test=test, train=train, console=TRUE,
assign.eval_tbl=FALSE, eval_tbl.name="eval_tbl",
print.eval_tbl=FALSE, return.eval_tbl = FALSE) {
# construct tmp df
eval_df <- tibble(raw = ts,
model = c(forecast$fitted, rep(NA, length(test))),   #NEED TO DROP/ADD THE +1 - used it for lstm
forecasted = c(rep(NA, length(train)), forecast$mean))
# residuals
eval_df$residuals <- eval_df$raw - eval_df$model  #i.e., forecast$residuals
eval_df$error <- eval_df$raw - eval_df$forecasted
eval_df$error_pct <- eval_df$error / eval_df$raw
# kpis
residuals_mean <- eval_df %.>% .$residuals %.>% mean(., na.rm = T)
residuals_sd <- eval_df %.>% .$residuals %.>% sd(., na.rm = T)
error_mean <- eval_df %.>% .$error %.>% mean(., na.rm = T)
error_sd <- eval_df %.>% .$error %.>% sd(., na.rm = T)
mae <- eval_df %.>% .$error %.>% abs(.) %.>% mean(., na.rm = T)
mape <- eval_df %.>% .$error_pct %.>% abs(.) %.>% mean(., na.rm = T)
mse <- eval_df %.>% .$error %.>% .^2 %.>% mean(., na.rm = T)
rmse <- mse %.>% sqrt(.)
# print results to console or to a table
#print to console
if (console) {
cat(glue("
------------------------------------
Evaluation of Algorithm Performance
------------------------------------
Training:
residuals mean: {round(residuals_mean)}
sd: {round(residuals_sd)}\n
Test:
error mean: {round(error_mean)}
sd: {round(error_sd)}
mae: {round(mae)}
mape: {round(mape*100)}%
mse: {round(mse)}
rmse: {round(rmse)}
test ratio:
test mean: {round(mean(test))}
rmse-mean ratio: {round(100*(rmse/mean(test)), 1)}%
------------------------------------"))
}
#create title reporting custom model specification
str_index <- function (forecast, start=NULL, stop=NULL, int=TRUE) {
#i=14,16,18 are standard seasonal parameters for forecast$method with ARIMA
if (int) {
as.integer(substr(forecast$method,
start=start,
stop=stop))
} else {
substr(forecast$method,
start=start,
stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
#create and assign table
eval_tbl <- tibble(
statistic=c("residuals_mean",
"residuals_sd",
"error_mean",
"error_sd",
"mae",
"mape.perc",
"mse",
"rmse",
"test_mean",
"rmse_test_mean_ratio.perc"),
values=c(round(residuals_mean),
round(residuals_sd),
round(error_mean),
round(error_sd),
round(mae),
round(mape*100),
round(mse),
round(rmse),
round(mean(test)),
round(100*(rmse/mean(test)), 1))
)
colnames(eval_tbl) <- c("Statistic", glue("{cu.subtitle}"))
if (assign.eval_tbl) {
assign(eval_tbl.name, eval_tbl, envir = .GlobalEnv)
} #declare user-defined tibble name
#conditioning output for a returned tibble for inline use
if (return.eval_tbl) {
return(eval_tbl)
}
#conditioning output for table to plot area
if (print.eval_tbl) {
ggplot() + ggpmisc::geom_table_npc(data=eval_tbl, label=list(eval_tbl),
npcx=0.5, npcy=0.5, size=10) +
theme(plot.title = element_text(hjust=0.5, vjust=2, size=25))
}
}
plot_eval_forecast(ts, fx.2, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.2, train = train, test = test) #mape: 17%
fx.3 <- fc_fn(ts, modelvar = "tbats", eval_fc_output = "return fc object")
plot_eval_forecast(ts, fx.3, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.3, train = train, test = test) #mape:
plot_eval_forecast(ms_ts, fx.4, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ms_ts, fx.4, train = train, test = test) #mape:
z_ts <- read.zoo(ts_clean$sales, format="%Y-%m-%d")
z_ts <- read.zoo(ts_clean, format="%Y-%m-%d")
plot_eval_forecast(ts, fx.3, train=train, test=test, og_df.date_col = ts_clean$date)
# forecast 5: arima w/ zoo object (no forced seasonality)
train_test_split(ts, split_perc = 0.85, full_df = T, ts_col = ts_clean$sales)
# forecast 5: arima w/ zoo object (no forced seasonality)
train_test_split(z_ts, split_perc = 0.85, full_df = T, ts_col = ts_clean$sales)
fx.5 <- fc_fn(z_ts, modelvar = "arima", eval_fc_output = "return fc object",
autoarima = TRUE)
train$sales
help(zoo)
z_ts <- zoo(ts_clean$sales, format="%Y-%m-%d")
z_ts <- zoo(ts_clean$sales)
z_ts
# forecast 5: arima w/ zoo object (no forced seasonality)
train_test_split(z_ts, split_perc = 0.85, full_df = T, ts_col = ts_clean$sales)
fx.5 <- fc_fn(z_ts, modelvar = "arima", eval_fc_output = "return fc object",
autoarima = TRUE)
plot_eval_forecast(z_ts, fx.5, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(z_ts, fx.5, train = train, test = test) #mape: 17%
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(3,1,3),
seasonal=list(order=c(1,1,1),
period=365)))
ts <- ts(ts_clean$sales, start=as.Date("2013-01-01"), frequency = 7)
plot_eval_forecast(ts, fx.2, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.2, train = train, test = test) #mape: 17%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(2,0,1),
seasonal=list(order=c(1,1,1),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(2,0,1),
seasonal=list(order=c(0,0,1),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(2,0,1),
seasonal=list(order=c(0,1,0),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(3,1,3),
seasonal=list(order=c(1,1,1),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(2,1,0),
seasonal=list(order=c(2,1,0),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 23%
plot_acf_pacf(ts_clean, ci=0.95, diff=T)
fx.1 <- fc_fn(ts, modelvar = "arima", eval_fc_output = "return fc object",
manual.arima.spec = arima(train,
order=c(2,0,1),
seasonal=list(order=c(0,1,0),
period=7)))
plot_eval_forecast(ts, fx.1, train=train, test=test, og_df.date_col = ts_clean$date)
eval_forecast(ts, fx.1, train = train, test = test) #mape: 20%
# Check to see how tight the lags are within the residual CIs (ACF/PACF)
tsdisplay(residuals(fit_arima), lag.max=30, main='Seasonal Model Residuals')
