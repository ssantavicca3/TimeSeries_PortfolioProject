error_mean <- eval_df %.>% .$error %.>% mean(., na.rm = T)
error_sd <- eval_df %.>% .$error %.>% sd(., na.rm = T)
mae <- eval_df %.>% .$error %.>% abs(.) %.>% mean(., na.rm = T)
mape <- eval_df %.>% .$error_pct %.>% abs(.) %.>% mean(., na.rm = T)
mse <- eval_df %.>% .$error %.>% .^2 %.>% mean(., na.rm = T)
rmse <- mse %.>% sqrt(.)
# intervals
eval_df$ci_lo <- eval_df$forecasted - 1.96*residuals_sd #confidence
eval_df$ci_up <- eval_df$forecasted + 1.96*residuals_sd
eval_df$pi_lo <- eval_df$forecasted - 1.96*error_sd #prediction
eval_df$pi_up <- eval_df$forecasted + 1.96*error_sd
# plot results
theme_4panel <- function(base_size = 12,
base_family = ""){
theme_minimal(base_size = base_size,
base_family = base_family) %+replace%
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust=0.5, vjust=2, size=11),
panel.border = element_rect(color="black", fill=NA, size=.5),
legend.position = NULL,
legend.key.size = unit(1, "lines"),
legend.key.height = unit(0.7, "lines"),
legend.key.width = unit(0.7, "lines"),
legend.margin = margin(0, 0.1, 0.05, 0.1, "cm"),
legend.background = element_rect(color = 'black',
fill = 'white',
linetype = 'solid'),
legend.title = element_blank(),
legend.text = element_text(size = 10)
)
} #customizing theme_minimal()
#...training
p1 <- ggplot(eval_df[1:length(train),], aes(x=date)) +
geom_line(aes(y=raw, color="ts"), size=1) +
geom_line(aes(y=model, color="model"), size=1) +
labs(x=NULL, y='', title='Model') +
scale_color_manual(name="",
values=c("ts"="black",
"model"="#3399FF")) +
#might have to automate ylim again
ylim(c(-500, 15000))  +
theme_4panel() +
theme(legend.position = c(.075,.89)) +
scale_x_date(breaks="6 months", date_labels = "%b-%Y",
limits=c(eval_df$date[1], max=eval_df$date[length(train)]),
expand=c(0,0))
#...test
p2 <- ggplot(eval_df[length(train):length(eval_df$raw),], aes(x=date)) +
geom_ribbon(aes(ymin=pi_lo, ymax=pi_up), fill="blue", alpha=0.3) +
geom_ribbon(aes(ymin=ci_lo, ymax=ci_up), fill="lightblue", alpha=0.6) +
geom_line(aes(y=raw, color="ts"), size=1) +
geom_line(aes(y=forecasted, color="forecast"), size=1) +
labs(x='', y='', title='Forecast') +
scale_color_manual(name="",
values=c("ts"="black",
"forecast"="red")) +
ylim(c(-500, 15000)) +
theme_4panel() +
theme(legend.position = c(.91,.89)) +
scale_x_date(breaks="1 month", date_labels = "%b",
limits=c(eval_df$date[length(train)], max=max(eval_df$date)),
expand=c(0,0))
#...residuals
p3 <- ggplot(eval_df, aes(x=date)) +
geom_line(data = eval_df[1:length(train),],
aes(y=residuals, color="residuals"), size=1) +
geom_line(data = eval_df[length(train):length(eval_df$raw),],
aes(y=error, color="error"), size=1) +
labs(x='', y='', title='Residuals') +
scale_color_manual(name="",
values=c("residuals"="#3399FF",
"error"="red")) +
theme_4panel() +
theme(legend.position = c(.095,.89)) +
scale_x_date(breaks="6 months", date_labels = "%b-%Y",
limits=c(eval_df$date[1], max=max(eval_df$date)),
expand=c(0,0))
#...residuals distribution
p4 <- ggplot(eval_df) +
geom_density(data = eval_df[length(train):length(eval_df$raw),],
aes(x=error, color="error"), alpha=0.1, size=1, fill="red") +
geom_density(data = eval_df[1:length(train),],
aes(x=residuals, color="residuals"), alpha=0.2, size=1, fill="#3399FF") +
labs(x='', y='', title='Residuals Distribution') +
geom_vline(aes(xintercept=mean(error, na.rm=T), color="error"),
size=1, linetype="dashed") +
geom_vline(aes(xintercept=mean(residuals, na.rm=T), color="residuals"),
size=1, linetype="dashed") +
scale_color_manual(name="",
values=c("residuals"="#3399FF",
'error'="red")) +
scale_fill_manual(name="",
values=c('residuals'="#3399FF",
'error'="red")) +
theme_4panel() +
theme(legend.position = c(.905,.89))
# create subtitle reporting custom model specification
str_index <- function (forecast, start=NULL, stop=NULL, int=TRUE) {
#i=14,16,18 are standard seasonal parameters for forecast$method with ARIMA
if (int) {
as.integer(substr(forecast$method,
start=start,
stop=stop))
} else {
substr(forecast$method,
start=start,
stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
# display plot panel
(p1 + p2) /
(p3 + p4) +
plot_annotation(
title = 'Evaluation of Model Performance',
subtitle = paste('Model Specification:', sep=" ", cu.subtitle),
caption = glue('Training set :  n={length(train)} ({round(100*(length(train)/(length(train)+length(test))))}%)
Test set :         n={length(test)} ({round(100*(length(test)/(length(train)+length(test))))}%)'),
theme = theme(plot.title = element_text(hjust=0.5, size=15, face="bold"),
plot.subtitle = element_text(hjust=0.5, size=12)))
# Alternative color options:
# darkish green: #009900
# good blue: #3399FF
# thicker turquiose: #00CCCC
# deeper near-burghandy red: #CC3333
# brighter off-red: #FF6666
}
plot_eval_forecast(ms_ts, forecast, og_df.date_col = ts_df$date)
plot_eval_forecast(ms_ts, forecast, og_df.date_col = ts_df$date)
forecast$fitted
eval_forecast <- function (ts, forecast, test=test, train=train, console=TRUE,
assign.eval_tbl=FALSE, eval_tbl.name="eval_tbl",
print.eval_tbl=FALSE, return.eval_tbl = FALSE) {
# construct tmp df
eval_df <- tibble(raw = ts,
model = c(forecast$fitted, rep(NA, length(test))),   #NEED TO DROP/ADD THE +1 - used it for lstm
forecasted = c(rep(NA, length(train)), forecast$mean))
# residuals
eval_df$residuals <- eval_df$raw - eval_df$model  #i.e., forecast$residuals
eval_df$error <- eval_df$raw - eval_df$forecasted
eval_df$error_pct <- eval_df$error / eval_df$raw
# kpis
residuals_mean <- eval_df %.>% .$residuals %.>% mean(., na.rm = T)
residuals_sd <- eval_df %.>% .$residuals %.>% sd(., na.rm = T)
error_mean <- eval_df %.>% .$error %.>% mean(., na.rm = T)
error_sd <- eval_df %.>% .$error %.>% sd(., na.rm = T)
mae <- eval_df %.>% .$error %.>% abs(.) %.>% mean(., na.rm = T)
mape <- eval_df %.>% .$error_pct %.>% abs(.) %.>% mean(., na.rm = T)
mse <- eval_df %.>% .$error %.>% .^2 %.>% mean(., na.rm = T)
rmse <- mse %.>% sqrt(.)
# print results to console or to a table
#print to console
if (console) {
cat(glue("
------------------------------------
Evaluation of Algorithm Performance
------------------------------------
Training:
residuals mean: {round(residuals_mean)}
sd: {round(residuals_sd)}\n
Test:
error mean: {round(error_mean)}
sd: {round(error_sd)}
mae: {round(mae)}
mape: {round(mape*100)}%
mse: {round(mse)}
rmse: {round(rmse)}
test ratio:
test mean: {round(mean(test))}
rmse-mean ratio: {round(100*(rmse/mean(test)), 1)}%
------------------------------------"))
}
#create title reporting custom model specification
str_index <- function (forecast, start=NULL, stop=NULL, int=TRUE) {
#i=14,16,18 are standard seasonal parameters for forecast$method with ARIMA
if (int) {
as.integer(substr(forecast$method,
start=start,
stop=stop))
} else {
substr(forecast$method,
start=start,
stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
#create and assign table
eval_tbl <- tibble(
statistic=c("residuals_mean",
"residuals_sd",
"error_mean",
"error_sd",
"mae",
"mape.perc",
"mse",
"rmse",
"test_mean",
"rmse_test_mean_ratio.perc"),
values=c(round(residuals_mean),
round(residuals_sd),
round(error_mean),
round(error_sd),
round(mae),
round(mape*100),
round(mse),
round(rmse),
round(mean(test)),
round(100*(rmse/mean(test)), 1))
)
colnames(eval_tbl) <- c("Statistic", glue("{cu.subtitle}"))
if (assign.eval_tbl) {
assign(eval_tbl.name, eval_tbl, envir = .GlobalEnv)
} #declare user-defined tibble name
#conditioning output for a returned tibble for inline use
if (return.eval_tbl) {
return(eval_tbl)
}
#conditioning output for table to plot area
if (print.eval_tbl) {
ggplot() + ggpmisc::geom_table_npc(data=eval_tbl, label=list(eval_tbl),
npcx=0.5, npcy=0.5, size=10) +
theme(plot.title = element_text(hjust=0.5, vjust=2, size=25))
}
}
eval_forecast(ts, forecast, console=F, return.eval_tbl=F, print.eval_tbl = T)
fc_fn <- function (ts=ts, train_test_split = TRUE, split_perc=0.85,
fc_len=NULL, assign_fc_obj = c(FALSE, NULL),
eval_fc_output=NULL,
modelvar=c("arima","tbats"),
autoarima=FALSE,
autoarima.spec = auto.arima(y = train, max.order = 20,
max.p = 10, max.d = 3, max.q = 10,
max.P = 10, max.D = 3, max.Q = 10,
stepwise = TRUE, seasonal = TRUE,
stationary = FALSE,
ic = "aic", trace = TRUE),
manual.arima.spec = arima(y = train,
order=c(2,1,0)),
manual.tbats.spec = tbats(y = train, trace = TRUE)) {
# create the training and test sets
if (train_test_split) {
train_test_split(ts, split_perc = split_perc)
} ### DO I NEED THE BOOLEAN HERE? i.e., SHOULDN'T I GIVE OPTION TO INPUT OWN TRAIN/TEST SETS?
# fit the model and create forecast object
if (modelvar == "arima") {
if (autoarima == TRUE) {
model <- autoarima.spec
} else {
# for seasonality, include seasonal=list(order=c(w,x,y, period=z) in manual.arima.spec()
model <- manual.arima.spec
}
} else if (modelvar == "tbats") {
model <- manual.tbats.spec
}
#allowing for manual forecast horizon
if (is.null(fc_len)) {
forecast <- forecast(model, h = length(test), level = c(80, 95, 99))
} else {
forecast <- forecast(model, h = fc_len, level = c(80, 95, 99))
}
# (optional) assign forecast to GlobalEnv w/ user-defined name
if (assign_fc_obj[1]) {
assign(assign_fc_obj[2], forecast, envir = .GlobalEnv)
}
# (optional) console, plot, and return output:
#options: c(report", "return fc object")
if (any(eval_fc_output %like% c("report"))) {
eval_forecast(ts, forecast)
plot_eval_forecast(ts, forecast, og_df.date_col = ts_df$date)
} else if (any(eval_fc_output %like% "return fc object")) {
return(forecast)
}
}
fc_fn(ts, modelvar = "arima", autoarima = FALSE, assign_fc_obj = c(TRUE, "fc.1"),
manual.arima.spec = arima(train,
order=c(2,1,1),
seasonal=list(order=c(1,1,1), period=7)),
eval_fc_output = "report")
fc_fn <- function (ts=ts, train_test_split = TRUE, split_perc=0.85,
fc_len=NULL, assign_fc_obj = c(FALSE, NULL),
eval_fc_output=NULL,
modelvar=c("arima","tbats"),
autoarima=FALSE,
autoarima.spec = auto.arima(y = train, max.order = 20,
max.p = 10, max.d = 3, max.q = 10,
max.P = 10, max.D = 3, max.Q = 10,
stepwise = TRUE, seasonal = TRUE,
stationary = FALSE,
ic = "aic", trace = TRUE),
manual.arima.spec = arima(y = train,
order=c(2,1,0)),
manual.tbats.spec = tbats(y = train, trace = TRUE)) {
# create the training and test sets
if (train_test_split) {
train_test_split(ts, split_perc = split_perc)
} ### DO I NEED THE BOOLEAN HERE? i.e., SHOULDN'T I GIVE OPTION TO INPUT OWN TRAIN/TEST SETS?
# fit the model and create forecast object
if (modelvar == "arima") {
if (autoarima == TRUE) {
model <- autoarima.spec
} else {
# for seasonality, include seasonal=list(order=c(w,x,y, period=z) in manual.arima.spec()
model <- manual.arima.spec
}
} else if (modelvar == "tbats") {
model <- manual.tbats.spec
}
#allowing for manual forecast horizon
if (is.null(fc_len)) {
forecast <- forecast(model, h = length(test), level = c(80, 95, 99))
} else {
forecast <- forecast(model, h = fc_len, level = c(80, 95, 99))
}
# (optional) assign forecast to GlobalEnv w/ user-defined name
if (assign_fc_obj[1]) {
assign(assign_fc_obj[2], forecast, envir = .GlobalEnv)
}
# (optional) console, plot, and return output:
#options: c(report", "return fc object")
if (any(eval_fc_output %like% c("report"))) {
eval_forecast(ts, forecast)
plot_eval_forecast(ts, forecast, og_df.date_col = ts_df$date)
} else if (any(eval_fc_output %like% "return fc object")) {
return(forecast)
}
}
fc_fn(ts, modelvar = "arima", autoarima = FALSE, assign_fc_obj = c(TRUE, "fc.1"),
manual.arima.spec = arima(train,
order=c(2,1,1),
seasonal=list(order=c(1,1,1), period=7)),
eval_fc_output = "report")
eval_forecast <- function (ts, forecast, test=test, train=train, console=TRUE,
assign.eval_tbl=FALSE, eval_tbl.name="eval_tbl",
print.eval_tbl=FALSE, return.eval_tbl = FALSE) {
# construct tmp df
eval_df <- tibble(raw = ts,
model = c(forecast$fitted, rep(NA, length(test))),   #NEED TO DROP/ADD THE +1 - used it for lstm
forecasted = c(rep(NA, length(train)), forecast$mean))
# residuals
eval_df$residuals <- eval_df$raw - eval_df$model  #i.e., forecast$residuals
eval_df$error <- eval_df$raw - eval_df$forecasted
eval_df$error_pct <- eval_df$error / eval_df$raw
# kpis
residuals_mean <- eval_df %.>% .$residuals %.>% mean(., na.rm = T)
residuals_sd <- eval_df %.>% .$residuals %.>% sd(., na.rm = T)
error_mean <- eval_df %.>% .$error %.>% mean(., na.rm = T)
error_sd <- eval_df %.>% .$error %.>% sd(., na.rm = T)
mae <- eval_df %.>% .$error %.>% abs(.) %.>% mean(., na.rm = T)
mape <- eval_df %.>% .$error_pct %.>% abs(.) %.>% mean(., na.rm = T)
mse <- eval_df %.>% .$error %.>% .^2 %.>% mean(., na.rm = T)
rmse <- mse %.>% sqrt(.)
# print results to console or to a table
#print to console
if (console) {
cat(glue("
------------------------------------
Evaluation of Algorithm Performance
------------------------------------
Training:
residuals mean: {round(residuals_mean)}
sd: {round(residuals_sd)}\n
Test:
error mean: {round(error_mean)}
sd: {round(error_sd)}
mae: {round(mae)}
mape: {round(mape*100)}%
mse: {round(mse)}
rmse: {round(rmse)}
test ratio:
test mean: {round(mean(test))}
rmse-mean ratio: {round(100*(rmse/mean(test)), 1)}%
------------------------------------"))
}
#create title reporting custom model specification
str_index <- function (forecast, start=NULL, stop=NULL, int=TRUE) {
#i=14,16,18 are standard seasonal parameters for forecast$method with ARIMA
if (int) {
as.integer(substr(forecast$method,
start=start,
stop=stop))
} else {
substr(forecast$method,
start=start,
stop=stop)
}
}
if (str_index(forecast, start=1, stop=5, int=F) == "ARIMA") {
first_s_value <- str_index(forecast, start=14,stop=14, int=F)
if (first_s_value != "" || !is.na(first_s_value)) {
#if expanding this for exogenous covariate series, condition "X" as well
cu.subtitle <- paste("S", sep = "", forecast$method)
}
} else {
cu.subtitle <- forecast$method
}
#create and assign table
eval_tbl <- tibble(
statistic=c("residuals_mean",
"residuals_sd",
"error_mean",
"error_sd",
"mae",
"mape.perc",
"mse",
"rmse",
"test_mean",
"rmse_test_mean_ratio.perc"),
values=c(round(residuals_mean),
round(residuals_sd),
round(error_mean),
round(error_sd),
round(mae),
round(mape*100),
round(mse),
round(rmse),
round(mean(test)),
round(100*(rmse/mean(test)), 1))
)
colnames(eval_tbl) <- c("Statistic", glue("{cu.subtitle}"))
if (assign.eval_tbl) {
assign(eval_tbl.name, eval_tbl, envir = .GlobalEnv)
} #declare user-defined tibble name
#conditioning output for a returned tibble for inline use
if (return.eval_tbl) {
return(eval_tbl)
}
#conditioning output for table to plot area
if (print.eval_tbl) {
ggplot() + ggpmisc::geom_table_npc(data=eval_tbl, label=list(eval_tbl),
npcx=0.5, npcy=0.5, size=10) +
theme(plot.title = element_text(hjust=0.5, vjust=2, size=25))
}
}
fc_fn(ts, modelvar = "arima", autoarima = FALSE, assign_fc_obj = c(TRUE, "fc.1"),
manual.arima.spec = arima(train,
order=c(2,1,1),
seasonal=list(order=c(1,1,1), period=7)),
eval_fc_output = "report")
df <- read.csv("Data/sales_train.csv")
# Format datetime column
df$date <- as.Date(df$date, "%d.%m.%Y")        #for ordering
## Create "sales" series with a daily frequency datetime index
# Create time series by aggregating daily sales
ts_df <- df %>%
group_by(date) %>%
summarise(sales = sum(item_cnt_day))
## Create time-series objects
#zoo: no forced seasonality, good w/ daily data
z_ts <- read.zoo(ts_df, format="%Y-%m-%d")
#ts; forced seasonality, crap with daily data (needed for 's' in auto.arima())
ts <- ts(ts_df$sales, start=as.Date("2013-01-01"), frequency = 7)
#msts; account for multiple seasonal patterns (needed for TBATS)
ms_ts <- msts(ts_df$sales, seasonal.periods = c(7,365.25))
## Predict sales and plot forecast
# Write a function to split ts and output train and test sets (NOTE: COULD JUST MERGE THESE TWO F'Ns)
# option A: output a single series(test/train) with a call. Could be used in-line
train_test_split <- function (ts, split_perc=0.85, out.train=F,
out.test=F, full_df=F, ts_col=NULL) {
# input either ts object or ts df
if (full_df) {
train <- head(ts, round(length(ts_col) * split_perc))
h <- length(ts_col) - round(length(ts_col) * split_perc)
test <- tail(ts, h)
} else {
train <- head(ts, round(length(ts) * split_perc))
h <- length(ts) - length(train)
test <- tail(ts, h)
}
# return train or test
if (out.train) {
return(train)
}
if (out.test) {
return(test)
}
}
train <- train_test_split(z_ts, split_perc = 0.85, out.train=T)
test <- train_test_split(z_ts, split_perc = 0.85, out.test=T)
# option B: output both train + test to the global environment with a single call.
train_test_split <- function (ts, split_perc=0.85, full_df=F, ts_col=NULL) {
# input either ts object or ts df
if (full_df) {
train <- head(ts, round(length(ts_col) * split_perc))
h <- length(ts_col) - round(length(ts_col) * split_perc)
test <- tail(ts, h)
} else {
train <- head(ts, round(length(ts) * split_perc))
h <- length(ts) - length(train)
test <- tail(ts, h)
}
# assign both train and test to global env
assign("train", train, envir = .GlobalEnv)
assign("test", test, envir = .GlobalEnv)
}
